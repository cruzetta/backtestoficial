<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Dólar Alpha - Terminal de Alta Performance USD/BRL</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- TradingView Lightweight Charts - Biblioteca de alta performance -->
    <script src="https://unpkg.com/lightweight-charts/dist/lightweight-charts.standalone.production.js"></script>
    <!-- PapaParse para importação de CSV -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/PapaParse/5.3.2/papaparse.min.js"></script>
    <link href="https://fonts.googleapis.com/css2?family=Roboto+Mono:wght@400;700&family=Inter:wght@400;600;700&display=swap" rel="stylesheet">
    <style>
        body { font-family: 'Inter', sans-serif; background-color: #121214; color: #E1E1E6; }
        .font-mono { font-family: 'Roboto Mono', monospace; }
        .btn-primary {
            background-color: #8257E5; color: white; transition: background-color 0.2s;
        }
        .btn-primary:hover { background-color: #996DFF; }
        .btn-secondary {
            background-color: #29292E; color: #C4C4CC; transition: background-color 0.2s;
        }
        .btn-secondary:hover { background-color: #323238; }
        .card { background-color: #202024; border-radius: 8px; box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3); }
        .loader {
            border: 4px solid #29292E; border-top: 4px solid #8257E5; border-radius: 50%;
            width: 48px; height: 48px; animation: spin 1s linear infinite;
        }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
        #chartContainer { height: 60vh; position: relative; }
        .positive { color: #00B37E; }
        .negative { color: #F75A68; }
    </style>
</head>
<body>

    <!-- Loading Screen -->
    <div id="loadingScreen" class="fixed inset-0 bg-black z-50 flex items-center justify-center">
        <div class="text-center">
            <div class="loader inline-block"></div>
            <div id="loadingStatus" class="text-gray-400 mt-4 text-lg font-mono">Inicializando Terminal Alpha...</div>
        </div>
    </div>

    <!-- Main Application Container -->
    <div id="appContainer" class="hidden mx-auto p-6">
        <header class="mb-6 flex justify-between items-center border-b border-gray-700 pb-4">
            <h1 class="text-3xl font-bold text-transparent bg-clip-text bg-gradient-to-r from-purple-400 to-pink-600">Dólar Alpha</h1>
            <p class="text-sm text-gray-500">Plataforma Exclusiva USD/BRL</p>
        </header>

        <div class="grid grid-cols-1 lg:grid-cols-5 gap-6">
            
            <!-- Sidebar: Data Hub & Strategy Lab -->
            <div class="lg:col-span-1 space-y-6">
                
                <!-- Data Hub Section -->
                <div class="card p-4">
                    <h3 class="font-semibold text-xl mb-4 border-b border-gray-700 pb-2 text-purple-400">Data Hub</h3>
                    
                    <!-- 1. Real-Time Harvester -->
                    <div class="mb-6 p-3 bg-gray-800 rounded-lg">
                        <h4 class="text-sm font-semibold mb-2">Robô de Coleta (Tempo Real)</h4>
                        <p class="text-xs text-gray-500 mb-3">Coleta a cada 3s (Simulação)</p>
                        <button id="toggleCaptureBtn" class="w-full btn-primary py-2 px-4 rounded-lg text-sm font-bold bg-green-600 hover:bg-green-700">
                            Iniciar Coleta
                        </button>
                        <div id="captureStatus" class="text-center text-xs font-mono pt-2 h-12 flex items-center justify-center">Status: Inativo</div>
                    </div>

                    <!-- 2. Data Loader -->
                    <div class="space-y-4">
                        <h4 class="text-sm font-semibold">Carregar Dados</h4>
                        <button id="loadCapturedDataBtn" class="w-full btn-secondary py-2 px-4 rounded-lg text-sm">
                            Usar Dados Capturados (DB)
                        </button>
                        <div class="text-center text-gray-500 text-xs">OU</div>
                        <label class="block text-xs text-gray-400 mb-1">Upload CSV (Date/Time, OHLC)</label>
                        <input type="file" id="csvInput" accept=".csv" class="block w-full text-sm text-gray-400 file:mr-4 file:py-2 file:px-4 file:rounded-lg file:border-0 file:text-sm file:font-semibold file:bg-purple-600 file:text-white hover:file:bg-purple-700"/>
                        <div id="dataStatus" class="text-center text-xs text-gray-400 pt-2">Nenhum dado carregado.</div>
                    </div>
                </div>

                <!-- Strategy Lab Section -->
                <div id="strategyLab" class="card p-4 hidden">
                    <h3 class="font-semibold text-xl mb-4 border-b border-gray-700 pb-2 text-green-400">Strategy Lab</h3>
                    
                    <div class="space-y-4">
                        <div>
                            <label for="timeframeSelect" class="block mb-1 text-sm font-medium text-gray-300">Timeframe</label>
                            <select id="timeframeSelect" class="bg-gray-700 border border-gray-600 text-white text-sm rounded-lg focus:ring-purple-500 focus:border-purple-500 block w-full p-2.5">
                                <!-- Options populated by JS -->
                            </select>
                        </div>
                        
                        <h4 class="text-md font-semibold pt-2">Estratégia: Cruzamento de EMAs</h4>

                        <div>
                            <label for="fastEmaPeriod" class="block mb-1 text-sm font-medium text-gray-300">EMA Rápida</label>
                            <input type="number" id="fastEmaPeriod" value="9" min="2" class="bg-gray-700 border border-gray-600 text-white text-sm rounded-lg block w-full p-2.5">
                        </div>
                        <div>
                            <label for="slowEmaPeriod" class="block mb-1 text-sm font-medium text-gray-300">EMA Lenta</label>
                            <input type="number" id="slowEmaPeriod" value="21" min="2" class="bg-gray-700 border border-gray-600 text-white text-sm rounded-lg block w-full p-2.5">
                        </div>

                        <button id="runBacktestBtn" class="w-full btn-primary py-3 px-4 rounded-lg transition font-bold mt-4">
                            Executar Backtest
                        </button>
                        <button id="optimizeBtn" class="w-full btn-secondary py-2 px-4 rounded-lg transition text-sm">
                            Otimizar Parâmetros
                        </button>
                    </div>
                </div>
            </div>

            <!-- Main Content: Chart and Results -->
            <div class="lg:col-span-4 space-y-6">
                
                <!-- TradingView Chart -->
                <div class="card p-4">
                    <h3 class="font-semibold text-lg mb-4 text-center text-gray-200">USD/BRL - <span id="chartTimeframeLabel">Aguardando dados...</span></h3>
                    <div id="chartContainer"></div>
                </div>

                <!-- Backtest Results Dashboard -->
                <div id="resultsSection" class="hidden card p-6">
                    <h2 class="text-2xl font-bold text-center mb-6 text-transparent bg-clip-text bg-gradient-to-r from-green-400 to-blue-500">Dashboard de Performance</h2>
                    <div id="statsContainer" class="grid grid-cols-2 md:grid-cols-3 lg:grid-cols-5 gap-4 mb-6">
                        <!-- Stats populated by JS -->
                    </div>
                    
                    <h3 class="text-xl font-semibold mb-4">Curva de Capital</h3>
                    <div id="equityChartContainer" style="height: 300px;"></div>
                </div>

                <!-- Optimization Results -->
                <div id="optimizationResultsSection" class="hidden card p-6">
                    <h2 class="text-2xl font-bold text-center mb-6 text-purple-400">Resultados da Otimização</h2>
                     <div id="bestResultDisplay" class="bg-gray-800 border-2 border-green-500 p-4 rounded-lg mb-6 text-center max-w-md mx-auto"></div>
                    <div class="overflow-x-auto rounded-lg border border-gray-700" style="max-height: 400px;">
                        <table id="optimizationResultTable" class="min-w-full text-sm text-left text-gray-300 font-mono"></table>
                    </div>
                </div>

            </div>
        </div>
    </div>
    
    <script type="module">
        // --- Firebase Configuration (Using environment variables) ---
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { getAuth, onAuthStateChanged, signInAnonymously, signInWithCustomToken } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
        import { getFirestore, collection, addDoc, getDocs, query, serverTimestamp, limit, orderBy } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";

        // --- Global State Variables ---
        let app, auth, db, dataCaptureCollection;
        let priceChart, equityChart, candlestickSeries, equitySeries, fastEmaSeries, slowEmaSeries;
        let historicalData = []; // Base data
        let aggregatedData = []; // Data after timeframe aggregation
        
        let isCapturing = false;
        let captureInterval = null;
        let lastCaptureTimestamp = null;
        const CONTRACT_MULTIPLIER = 10; // Mini Dólar (WDO) R$10 per point

        // --- UI Element References ---
        const ui = {
            loadingScreen: document.getElementById('loadingScreen'),
            loadingStatus: document.getElementById('loadingStatus'),
            appContainer: document.getElementById('appContainer'),
            toggleCaptureBtn: document.getElementById('toggleCaptureBtn'),
            captureStatus: document.getElementById('captureStatus'),
            loadCapturedDataBtn: document.getElementById('loadCapturedDataBtn'),
            csvInput: document.getElementById('csvInput'),
            dataStatus: document.getElementById('dataStatus'),
            strategyLab: document.getElementById('strategyLab'),
            timeframeSelect: document.getElementById('timeframeSelect'),
            fastEmaPeriod: document.getElementById('fastEmaPeriod'),
            slowEmaPeriod: document.getElementById('slowEmaPeriod'),
            runBacktestBtn: document.getElementById('runBacktestBtn'),
            optimizeBtn: document.getElementById('optimizeBtn'),
            chartContainer: document.getElementById('chartContainer'),
            chartTimeframeLabel: document.getElementById('chartTimeframeLabel'),
            resultsSection: document.getElementById('resultsSection'),
            statsContainer: document.getElementById('statsContainer'),
            equityChartContainer: document.getElementById('equityChartContainer'),
            optimizationResultsSection: document.getElementById('optimizationResultsSection'),
            bestResultDisplay: document.getElementById('bestResultDisplay'),
            optimizationResultTable: document.getElementById('optimizationResultTable'),
        };
        
        // --- Initialization ---
        async function initialize() {
            const appId = typeof __app_id !== 'undefined' ? __app_id : 'default-app-id';
            
            // CORREÇÃO: Adicionado um objeto de configuração reserva (fallback) para permitir
            // a pré-visualização quando a variável de ambiente __firebase_config não estiver disponível.
            const firebaseConfig = typeof __firebase_config !== 'undefined' 
                ? JSON.parse(__firebase_config) 
                : {
                    apiKey: "AIzaSyCMIdzeoPFrT8WRElUBes7GTrcsoGzLBiI",
                    authDomain: "backtest-f5072.firebaseapp.com",
                    projectId: "backtest-f5072",
                    storageBucket: "backtest-f5072.appspot.com",
                    messagingSenderId: "694914388064",
                    appId: "1:694914388064:web:e5ac46c00612142d33b305"
                  };
            
            if (!firebaseConfig || !firebaseConfig.projectId) {
                ui.loadingStatus.textContent = "Erro: Configuração do Firebase inválida ou não encontrada.";
                return;
            }

            app = initializeApp(firebaseConfig);
            auth = getAuth(app);
            db = getFirestore(app);
            
            const collectionPath = `artifacts/${appId}/public/data/dolar_alpha_data`;
            dataCaptureCollection = collection(db, collectionPath);
            
            ui.loadingStatus.textContent = "Autenticando...";
            
            onAuthStateChanged(auth, async (user) => {
                if (user) {
                    console.log("User authenticated:", user.uid);
                    ui.loadingScreen.classList.add('hidden');
                    ui.appContainer.classList.remove('hidden');
                    setupCharts();
                    toggleCapture(); 
                } else {
                    try {
                        if (typeof __initial_auth_token !== 'undefined') {
                            await signInWithCustomToken(auth, __initial_auth_token);
                        } else {
                            await signInAnonymously(auth);
                        }
                    } catch (error) {
                        console.error("Authentication failed:", error);
                        ui.loadingStatus.textContent = "Falha na autenticação.";
                    }
                }
            });
        }

        // --- 1. DATA HARVESTER (Real-Time Capture Robot Simulation) ---

        async function captureDataPoint() {
            let price = null;
            let source = null;
            const timeoutMs = 2500;

            try {
                const controller = new AbortController();
                const timeoutId = setTimeout(() => controller.abort(), timeoutMs);
                const response = await fetch('https://economia.awesomeapi.com.br/last/USD-BRL?t=' + Date.now(), { signal: controller.signal, cache: 'no-store' });
                clearTimeout(timeoutId);
                if (!response.ok) throw new Error('Fonte A Status NOK');
                const data = await response.json();
                price = parseFloat(data.USDBRL.bid);
                source = 'A';
            } catch (error) {
                console.warn("Fonte A falhou:", error.message);
            }

            if (price === null) {
                try {
                    const controller = new AbortController();
                    const timeoutId = setTimeout(() => controller.abort(), timeoutMs);
                    const response = await fetch('https://cdn.jsdelivr.net/npm/@fawazahmed0/currency-api@latest/v1/currencies/usd.json?t=' + Date.now(), { signal: controller.signal, cache: 'no-store' });
                    clearTimeout(timeoutId);
                    if (!response.ok) throw new Error('Fonte B Status NOK');
                    const data = await response.json();
                    if (data.usd && data.usd.brl) {
                        price = parseFloat(data.usd.brl);
                        source = 'B';
                    }
                } catch (fallbackError) {
                    console.error("Ambas as fontes falharam:", fallbackError.message);
                }
            }
            
            if (price !== null && !isNaN(price)) {
                try {
                    await addDoc(dataCaptureCollection, {
                        price: price,
                        timestamp: serverTimestamp(),
                        source: source
                    });
                    lastCaptureTimestamp = new Date();
                    updateCaptureStatus(true, price, source);
                } catch (dbError) {
                    console.error("Erro ao salvar no DB:", dbError);
                    updateCaptureStatus(false, null, "DB Error");
                }
            } else if (isCapturing) {
                updateCaptureStatus(false, null, "API Error");
            }
        }

        function updateCaptureStatus(success, price, source) {
            let statusHTML = '';
            if (success) {
                statusHTML = `
                    <span class="text-green-400">ATIVO</span> | Fonte: ${source}
                    <br>Preço: <span class="font-bold">${price.toFixed(4)}</span> @ ${lastCaptureTimestamp.toLocaleTimeString()}
                `;
            } else if (isCapturing) {
                statusHTML = `<span class="text-yellow-400">FALHA (${source})</span> | Tentando novamente...`;
                 if (lastCaptureTimestamp) {
                       statusHTML += ` (Última: ${lastCaptureTimestamp.toLocaleTimeString()})`;
                 }
            } else {
                statusHTML = 'Status: <span class="text-gray-500">Pausado</span>';
            }
            ui.captureStatus.innerHTML = statusHTML;
        }

        function toggleCapture() {
            if (isCapturing) {
                clearInterval(captureInterval);
                isCapturing = false;
                ui.toggleCaptureBtn.textContent = 'Retomar Coleta';
                ui.toggleCaptureBtn.classList.remove('bg-red-600', 'hover:bg-red-700');
                ui.toggleCaptureBtn.classList.add('bg-green-600', 'hover:bg-green-700');
                updateCaptureStatus(false);
            } else {
                isCapturing = true;
                ui.toggleCaptureBtn.textContent = 'Pausar Coleta';
                ui.toggleCaptureBtn.classList.remove('bg-green-600', 'hover:bg-green-700');
                ui.toggleCaptureBtn.classList.add('bg-red-600', 'hover:bg-red-700');
                ui.captureStatus.textContent = 'Iniciando conexão...';
                captureDataPoint();
                captureInterval = setInterval(captureDataPoint, 3000);
            }
        }

        // --- 2. DATA LOADING AND PROCESSING ---

        async function loadCapturedData() {
            ui.dataStatus.textContent = 'Carregando dados do DB (Firebase)...';
            try {
                const q = query(dataCaptureCollection, orderBy("timestamp", "desc"), limit(5000)); 
                const querySnapshot = await getDocs(q);
                
                let ticks = querySnapshot.docs.map(doc => {
                    const data = doc.data();
                    if (!data.timestamp) return null; 
                    return { price: data.price, date: data.timestamp.toDate() };
                }).filter(Boolean);

                ticks.sort((a, b) => a.date - b.date);

                if (ticks.length < 10) {
                    throw new Error("Não há dados capturados suficientes (mínimo 10 ticks).");
                }

                const candles = aggregateTicksToCandles(ticks, 1);
                historicalData = candles;
                ui.dataStatus.textContent = `Carregado: ${ticks.length} ticks -> ${candles.length} candles (1min).`;
                
                updateTimeframeSelector(['1min', '5min', '15min', '30min', '60min'], '5min');
                ui.strategyLab.classList.remove('hidden');
                processAndDisplayData();
            } catch (error) {
                console.error("Erro ao carregar dados capturados:", error);
                ui.dataStatus.textContent = `Erro: ${error.message}. Pode ser necessário criar um índice no Firestore.`;
            }
        }

        function handleFileUpload(file) {
            if (!file) return;
            ui.dataStatus.textContent = 'Processando arquivo CSV...';
            Papa.parse(file, {
                header: true, dynamicTyping: true, skipEmptyLines: true,
                complete: (results) => {
                    try {
                        const parsedData = results.data.map(row => {
                            const dateKey = Object.keys(row).find(k => k.toLowerCase().includes('date') || k.toLowerCase().includes('time'));
                            const openKey = Object.keys(row).find(k => k.toLowerCase() === 'open');
                            const highKey = Object.keys(row).find(k => k.toLowerCase() === 'high');
                            const lowKey = Object.keys(row).find(k => k.toLowerCase() === 'low');
                            const closeKey = Object.keys(row).find(k => k.toLowerCase() === 'close');
                            
                            if (!dateKey || !openKey || !highKey || !lowKey || !closeKey) return null;

                            const date = new Date(row[dateKey]);
                            if (isNaN(date.getTime())) return null;

                            return { 
                                date: date, 
                                open: parseFloat(row[openKey]), 
                                high: parseFloat(row[highKey]), 
                                low: parseFloat(row[lowKey]), 
                                close: parseFloat(row[closeKey]) 
                            };
                        }).filter(Boolean).sort((a, b) => a.date - b.date);

                        if (parsedData.length === 0) throw new Error("CSV vazio ou formato inválido.");

                        historicalData = parsedData;
                        
                        const intervalMs = historicalData.length > 1 ? historicalData[1].date - historicalData[0].date : 0;
                        const isDaily = intervalMs >= (24 * 60 * 60 * 1000) - (60 * 1000);

                        if (isDaily) {
                             ui.dataStatus.textContent = `Carregado: ${historicalData.length} dias.`;
                             updateTimeframeSelector(['Diário', 'Semanal', 'Mensal'], 'Diário');
                        } else {
                            ui.dataStatus.textContent = `Carregado: ${historicalData.length} candles intraday.`;
                             updateTimeframeSelector(['1min', '5min', '15min', '30min', '60min'], '5min');
                        }

                        ui.strategyLab.classList.remove('hidden');
                        processAndDisplayData();
                    } catch (error) {
                        ui.dataStatus.textContent = `Erro: ${error.message}`;
                        console.error('Erro ao processar o CSV.');
                    }
                }
            });
        }

        function aggregateTicksToCandles(ticks, intervalMinutes) {
            const candles = [];
            let currentCandle = null;
            const intervalMs = intervalMinutes * 60000;

            for (const tick of ticks) {
                const intervalStart = new Date(Math.floor(tick.date.getTime() / intervalMs) * intervalMs);

                if (!currentCandle || intervalStart.getTime() !== currentCandle.date.getTime()) {
                    if (currentCandle) candles.push(currentCandle);
                    currentCandle = { date: intervalStart, open: tick.price, high: tick.price, low: tick.price, close: tick.price };
                } else {
                    currentCandle.high = Math.max(currentCandle.high, tick.price);
                    currentCandle.low = Math.min(currentCandle.low, tick.price);
                    currentCandle.close = tick.price;
                }
            }
            if (currentCandle) candles.push(currentCandle);
            return candles;
        }

        function aggregateData(baseData, timeframe) {
            if (['1min', 'Diário'].includes(timeframe)) {
                return baseData;
            }

            const aggregated = [];
            let currentCandle = null;

            const getIntervalStart = (date) => {
                const d = new Date(date);
                if (timeframe === 'Semanal') {
                    const day = d.getUTCDay();
                    const start = new Date(d.getTime());
                    start.setUTCDate(d.getUTCDate() - day);
                    start.setUTCHours(0,0,0,0);
                    return start;
                } else if (timeframe === 'Mensal') {
                    return new Date(Date.UTC(d.getUTCFullYear(), d.getUTCMonth(), 1));
                } else {
                     const timeframeMinutes = parseInt(timeframe.replace('min', ''));
                    if (isNaN(timeframeMinutes)) return d;
                    const intervalMs = timeframeMinutes * 60000;
                    return new Date(Math.floor(d.getTime() / intervalMs) * intervalMs);
                }
            };

            for (const candle of baseData) {
                const intervalStart = getIntervalStart(candle.date);

                if (!currentCandle || intervalStart.getTime() !== currentCandle.date.getTime()) {
                    if (currentCandle) aggregated.push(currentCandle);
                    currentCandle = { ...candle, date: intervalStart };
                } else {
                    currentCandle.high = Math.max(currentCandle.high, candle.high);
                    currentCandle.low = Math.min(currentCandle.low, candle.low);
                    currentCandle.close = candle.close;
                }
            }
            if (currentCandle) aggregated.push(currentCandle);
            return aggregated;
        }

        function updateTimeframeSelector(options, defaultValue) {
            ui.timeframeSelect.innerHTML = '';
            options.forEach(opt => {
                const optionEl = document.createElement('option');
                optionEl.value = opt;
                optionEl.textContent = opt;
                ui.timeframeSelect.appendChild(optionEl);
            });
            if (defaultValue) ui.timeframeSelect.value = defaultValue;
        }

        function processAndDisplayData() {
            if (historicalData.length === 0) return;

            const selectedTimeframe = ui.timeframeSelect.value;
            ui.chartTimeframeLabel.textContent = selectedTimeframe;

            aggregatedData = aggregateData(historicalData, selectedTimeframe);
            
            if(aggregatedData.length === 0) {
                console.error("Nenhum dado após agregação.");
                return;
            }
            
            const fastPeriod = parseInt(ui.fastEmaPeriod.value);
            const slowPeriod = parseInt(ui.slowEmaPeriod.value);
            const dataWithIndicators = calculateIndicators(aggregatedData, fastPeriod, slowPeriod);

            updatePriceChart(dataWithIndicators);
            ui.resultsSection.classList.add('hidden');
            ui.optimizationResultsSection.classList.add('hidden');
        }

        // --- 3. CHARTING (TradingView Lightweight Charts) ---

        function setupCharts() {
            const chartOptions = {
                layout: {
                    backgroundColor: '#202024',
                    textColor: '#C4C4CC',
                },
                grid: {
                    vertLines: { color: '#29292E' },
                    horzLines: { color: '#29292E' },
                },
                rightPriceScale: {
                    borderColor: '#323238',
                },
                timeScale: {
                    borderColor: '#323238',
                    timeVisible: true,
                    secondsVisible: false,
                },
                crosshair: {
                    mode: LightweightCharts.CrosshairMode.Normal,
                },
                localization: {
                    locale: 'pt-BR',
                }
            };

            priceChart = LightweightCharts.createChart(ui.chartContainer, {...chartOptions, height: ui.chartContainer.clientHeight});
            candlestickSeries = priceChart.addCandlestickSeries({
                upColor: '#00B37E',
                downColor: '#F75A68',
                borderVisible: false,
                wickUpColor: '#00B37E',
                wickDownColor: '#F75A68',
            });
            
            fastEmaSeries = priceChart.addLineSeries({ color: '#FFC700', lineWidth: 2, title: 'EMA Rápida' });
            slowEmaSeries = priceChart.addLineSeries({ color: '#8257E5', lineWidth: 2, title: 'EMA Lenta' });

            equityChart = LightweightCharts.createChart(ui.equityChartContainer, {...chartOptions, height: 300});
            equitySeries = equityChart.addAreaSeries({
                topColor: 'rgba(0, 179, 126, 0.5)',
                bottomColor: 'rgba(0, 179, 126, 0.05)',
                lineColor: '#00B37E',
                lineWidth: 2,
            });

            window.addEventListener('resize', () => {
                if (ui.chartContainer.clientWidth > 0 && ui.chartContainer.clientHeight > 0) {
                   priceChart.resize(ui.chartContainer.clientWidth, ui.chartContainer.clientHeight);
                }
            });
        }

        function toChartTime(date) {
            return date.getTime() / 1000;
        }

        function updatePriceChart(data) {
            const chartData = data.map(d => ({
                time: toChartTime(d.date),
                open: d.open, high: d.high, low: d.low, close: d.close
            }));

            const fastEmaData = data.map(d => ({
                time: toChartTime(d.date),
                value: d.fastEma
            })).filter(d => d.value !== null && d.value !== undefined);

             const slowEmaData = data.map(d => ({
                time: toChartTime(d.date),
                value: d.slowEma
            })).filter(d => d.value !== null && d.value !== undefined);

            candlestickSeries.setData(chartData);
            fastEmaSeries.setData(fastEmaData);
            slowEmaSeries.setData(slowEmaData);
            
            const fastPeriod = ui.fastEmaPeriod.value;
            const slowPeriod = ui.slowEmaPeriod.value;
            fastEmaSeries.applyOptions({ title: `EMA(${fastPeriod})` });
            slowEmaSeries.applyOptions({ title: `EMA(${slowPeriod})` });

            priceChart.timeScale().fitContent();
        }
        
        function updateEquityChart(equityCurve) {
             const chartData = equityCurve.map(d => ({
                time: toChartTime(d.date),
                value: d.equity
            }));
            equitySeries.setData(chartData);
            equityChart.timeScale().fitContent();
        }

        function addMarkersToChart(trades) {
            const markers = trades.map(trade => ({
                time: toChartTime(trade.entryDate),
                position: trade.type === 'BUY' ? 'belowBar' : 'aboveBar',
                color: trade.type === 'BUY' ? '#2196F3' : '#FF9800',
                shape: trade.type === 'BUY' ? 'arrowUp' : 'arrowDown',
                text: trade.type
            }));
            candlestickSeries.setMarkers(markers);
        }

        // --- 4. STRATEGY LAB (Indicators and Backtesting) ---

        function calculateEMA(data, period) {
            const k = 2 / (period + 1);
            const emaValues = new Array(data.length).fill(null);
            if (data.length < period) return emaValues;

            let sum = 0;
            for (let i = 0; i < period; i++) {
                if (!data[i] || data[i].close === undefined) return emaValues;
                sum += data[i].close;
            }
            emaValues[period - 1] = sum / period;

            for (let i = period; i < data.length; i++) {
                emaValues[i] = (data[i].close * k) + (emaValues[i - 1] * (1 - k));
            }
            return emaValues;
        }

        function calculateIndicators(data, fastPeriod, slowPeriod) {
            const fastEmas = calculateEMA(data, fastPeriod);
            const slowEmas = calculateEMA(data, slowPeriod);

            return data.map((d, i) => ({
                ...d,
                fastEma: fastEmas[i],
                slowEma: slowEmas[i]
            }));
        }

        function generateSignals(data) {
            const signals = [];
            for (let i = 1; i < data.length; i++) {
                const prev = data[i-1];
                const curr = data[i];

                if (prev.fastEma && prev.slowEma && curr.fastEma && curr.slowEma) {
                    if (prev.fastEma < prev.slowEma && curr.fastEma > curr.slowEma) {
                        signals.push({ type: 'BUY', date: curr.date, price: curr.close });
                    }
                    else if (prev.fastEma > prev.slowEma && curr.fastEma < curr.slowEma) {
                        signals.push({ type: 'SELL', date: curr.date, price: curr.close });
                    }
                }
            }
            return signals;
        }

        function runBacktest(data, fastPeriod, slowPeriod) {
            if (data.length < Math.max(slowPeriod, fastPeriod)) {
                return { stats: null, trades: [], equityCurve: [] };
            }

            const dataWithIndicators = calculateIndicators(data, fastPeriod, slowPeriod);
            const signals = generateSignals(dataWithIndicators);
            
            const trades = [];
            let position = 'FLAT';
            let entryTrade = null;
            let equity = 0;
            const equityCurve = [{ date: data[0].date, equity: 0 }];

            for (const signal of signals) {
                if (position === 'FLAT') {
                    position = signal.type === 'BUY' ? 'LONG' : 'SHORT';
                    entryTrade = signal;
                } else if ((position === 'LONG' && signal.type === 'SELL') || (position === 'SHORT' && signal.type === 'BUY')) {
                    const exitTrade = signal;
                    const profitPoints = (position === 'LONG') 
                        ? (exitTrade.price - entryTrade.price) 
                        : (entryTrade.price - exitTrade.price);
                    
                    const profit = profitPoints * 1000 * CONTRACT_MULTIPLIER; 
                    equity += profit;

                    trades.push({
                        type: entryTrade.type,
                        entryDate: entryTrade.date,
                        entryPrice: entryTrade.price,
                        exitDate: exitTrade.date,
                        exitPrice: exitTrade.price,
                        profit: profit
                    });
                    
                    equityCurve.push({ date: exitTrade.date, equity: equity });

                    position = signal.type === 'BUY' ? 'LONG' : 'SHORT';
                    entryTrade = signal;
                }
            }

            const stats = calculateStats(trades, equityCurve);
            return { stats, trades, equityCurve, dataWithIndicators };
        }

        function calculateStats(trades, equityCurve) {
            if (trades.length === 0) return { 
                totalProfit: 0, winRate: 0, maxDrawdown: 0, totalTrades: 0, profitFactor: 0
            };

            let totalProfit = 0;
            let grossProfit = 0;
            let grossLoss = 0;
            let wins = 0;

            for (const trade of trades) {
                totalProfit += trade.profit;
                if (trade.profit > 0) {
                    wins++;
                    grossProfit += trade.profit;
                } else {
                    grossLoss += Math.abs(trade.profit);
                }
            }

            const winRate = (wins / trades.length) * 100;
            const profitFactor = grossLoss === 0 ? (grossProfit > 0 ? Infinity : 1) : grossProfit / grossLoss;

            let peak = 0;
            let maxDrawdown = 0;
            equityCurve.forEach(point => {
                if (point.equity > peak) peak = point.equity;
                const drawdown = peak - point.equity;
                if (drawdown > maxDrawdown) maxDrawdown = drawdown;
            });

            return { totalProfit, winRate, maxDrawdown, totalTrades: trades.length, profitFactor };
        }

        function handleRunBacktest() {
            const fastPeriod = parseInt(ui.fastEmaPeriod.value);
            const slowPeriod = parseInt(ui.slowEmaPeriod.value);

            if (fastPeriod >= slowPeriod) {
                console.error("O período da EMA Rápida deve ser menor que o da EMA Lenta.");
                ui.dataStatus.textContent = "Erro: EMA Rápida >= EMA Lenta.";
                return;
            }

            const { stats, trades, equityCurve, dataWithIndicators } = runBacktest(aggregatedData, fastPeriod, slowPeriod);

            if (!stats) {
                console.error(`Dados insuficientes para os períodos selecionados.`);
                ui.dataStatus.textContent = "Erro: Dados insuficientes.";
                return;
            }

            updatePriceChart(dataWithIndicators);
            addMarkersToChart(trades);
            
            displayBacktestResults(stats);
            updateEquityChart(equityCurve);

            ui.resultsSection.classList.remove('hidden');
            ui.optimizationResultsSection.classList.add('hidden');
            ui.resultsSection.scrollIntoView({ behavior: 'smooth' });
        }

        // --- 5. OPTIMIZATION ---
        
        function handleOptimization() {
            ui.optimizeBtn.disabled = true;
            ui.optimizeBtn.textContent = "Otimizando...";
            
            setTimeout(() => {
                const results = [];
                const fastRange = [5, 8, 9, 13, 17, 21];
                const slowRange = [20, 21, 30, 34, 50, 72, 100];

                for (const fastPeriod of fastRange) {
                    for (const slowPeriod of slowRange) {
                        if (fastPeriod >= slowPeriod) continue;
                        if (aggregatedData.length < slowPeriod) continue;

                        const { stats } = runBacktest(aggregatedData, fastPeriod, slowPeriod);
                        if (stats && stats.totalTrades > 0) {
                            results.push({ fastPeriod, slowPeriod, ...stats });
                        }
                    }
                }

                displayOptimizationResults(results);
                ui.optimizeBtn.disabled = false;
                ui.optimizeBtn.textContent = "Otimizar Parâmetros";
                ui.optimizationResultsSection.scrollIntoView({ behavior: 'smooth' });
            }, 100);
        }

        // --- 6. UI Display Functions ---

        function formatCurrency(v) { 
            return new Intl.NumberFormat('pt-BR', { style: 'currency', currency: 'BRL' }).format(v); 
        }

        function displayBacktestResults(stats) {
            const fmtr = formatCurrency;
            const pfDisplay = isFinite(stats.profitFactor) ? stats.profitFactor.toFixed(2) : 'Infinito';

            ui.statsContainer.innerHTML = `
                <div class="bg-gray-700/50 p-4 rounded-lg text-center">
                    <p class="text-sm text-gray-400">Resultado Total</p>
                    <p class="text-xl font-bold font-mono ${stats.totalProfit >= 0 ? 'positive' : 'negative'}">${fmtr(stats.totalProfit)}</p>
                </div>
                <div class="bg-gray-700/50 p-4 rounded-lg text-center">
                    <p class="text-sm text-gray-400">Taxa de Acerto</p>
                    <p class="text-xl font-bold font-mono text-blue-400">${stats.winRate.toFixed(2)}%</p>
                </div>
                 <div class="bg-gray-700/50 p-4 rounded-lg text-center">
                    <p class="text-sm text-gray-400">Fator de Lucro</p>
                    <p class="text-xl font-bold font-mono text-purple-400">${pfDisplay}</p>
                </div>
                <div class="bg-gray-700/50 p-4 rounded-lg text-center">
                    <p class="text-sm text-gray-400">Drawdown Máximo</p>
                    <p class="text-xl font-bold font-mono negative">${fmtr(stats.maxDrawdown)}</p>
                </div>
                <div class="bg-gray-700/50 p-4 rounded-lg text-center">
                    <p class="text-sm text-gray-400">Total de Trades</p>
                    <p class="text-xl font-bold font-mono text-yellow-400">${stats.totalTrades}</p>
                </div>
            `;
        }

        function displayOptimizationResults(results) {
            const fmtr = formatCurrency;
            if (results.length === 0) {
                 ui.bestResultDisplay.innerHTML = "<p class='text-center text-gray-500'>Nenhuma combinação viável encontrada.</p>";
                 ui.optimizationResultTable.innerHTML = '';
                 ui.optimizationResultsSection.classList.remove('hidden');
                return;
            }

            results.sort((a, b) => {
                const pfA = isFinite(a.profitFactor) ? a.profitFactor : (a.profitFactor === Infinity ? 99999 : 0);
                const pfB = isFinite(b.profitFactor) ? b.profitFactor : (b.profitFactor === Infinity ? 99999 : 0);

                if (pfB !== pfA) {
                    return pfB - pfA;
                }
                return b.totalProfit - a.totalProfit;
            });

            const bestResult = results[0];
            const bestPFDisplay = isFinite(bestResult.profitFactor) ? bestResult.profitFactor.toFixed(2) : 'Infinito';

            ui.bestResultDisplay.innerHTML = `
                <p class="text-sm text-gray-400">Melhor Combinação (Maior Fator de Lucro)</p>
                <h4 class="text-2xl font-bold text-green-400">EMA(${bestResult.fastPeriod}) / EMA(${bestResult.slowPeriod})</h4>
                <p class="text-md text-gray-300">Lucro: <strong>${fmtr(bestResult.totalProfit)}</strong> | Fator: <strong>${bestPFDisplay}</strong></p>
            `;

            let tableHTML = `
                <thead class="text-xs text-gray-200 uppercase bg-gray-700 sticky top-0">
                    <tr>
                        <th class="px-4 py-2 text-center">Rápida</th>
                        <th class="px-4 py-2 text-center">Lenta</th>
                        <th class="px-4 py-2 text-right">Resultado</th>
                        <th class="px-4 py-2 text-right">Fator Lucro</th>
                        <th class="px-4 py-2 text-right">Acerto</th>
                        <th class="px-4 py-2 text-right">Trades</th>
                    </tr>
                </thead>
                <tbody>`;

            results.forEach((res, index) => {
                const isBest = index === 0;
                const pfDisplay = isFinite(res.profitFactor) ? res.profitFactor.toFixed(2) : 'Inf';
                tableHTML += `
                    <tr class="hover:bg-gray-700/50 ${isBest ? 'bg-green-800/30 font-bold' : ''}">
                        <td class="px-4 py-1 border-b border-gray-700 text-center">${res.fastPeriod}</td>
                        <td class="px-4 py-1 border-b border-gray-700 text-center">${res.slowPeriod}</td>
                        <td class="px-4 py-1 border-b border-gray-700 text-right ${res.totalProfit >= 0 ? 'positive' : 'negative'}">${fmtr(res.totalProfit)}</td>
                        <td class="px-4 py-1 border-b border-gray-700 text-right">${pfDisplay}</td>
                        <td class="px-4 py-1 border-b border-gray-700 text-right">${res.winRate.toFixed(1)}%</td>
                        <td class="px-4 py-1 border-b border-gray-700 text-right">${res.totalTrades}</td>
                    </tr>`;
            });
            ui.optimizationResultTable.innerHTML = tableHTML + '</tbody>';
            ui.resultsSection.classList.add('hidden');
            ui.optimizationResultsSection.classList.remove('hidden');
        }

        // --- Event Listeners ---
        document.addEventListener('DOMContentLoaded', initialize);
        ui.toggleCaptureBtn.addEventListener('click', toggleCapture);
        ui.loadCapturedDataBtn.addEventListener('click', loadCapturedData);
        ui.csvInput.addEventListener('change', (e) => handleFileUpload(e.target.files[0]));
        ui.timeframeSelect.addEventListener('change', processAndDisplayData);
        ui.fastEmaPeriod.addEventListener('change', processAndDisplayData);
        ui.slowEmaPeriod.addEventListener('change', processAndDisplayData);
        ui.runBacktestBtn.addEventListener('click', handleRunBacktest);
        ui.optimizeBtn.addEventListener('click', handleOptimization);

    </script>
</body>
</html>
