<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Day Trade Dólar PRO - Backtesting & Simulação</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/PapaParse/5.3.2/papaparse.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-adapter-date-fns/dist/chartjs-adapter-date-fns.bundle.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-chart-financial/dist/chartjs-chart-financial.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-zoom/dist/chartjs-plugin-zoom.min.js"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <style>
        body { font-family: 'Inter', sans-serif; }
        .loader {
            border: 4px solid #f3f3f3; border-top: 4px solid #3498db; border-radius: 50%;
            width: 48px; height: 48px; animation: spin 1s linear infinite;
        }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
        .chart-container { position: relative; height: 60vh; width: 100%; }
        .day-trade-info-value.positive { color: #22c55e; }
        .day-trade-info-value.negative { color: #ef4444; }
        #resultsSection, #optimizationResultsSection { scroll-margin-top: 20px; }
    </style>
</head>
<body class="bg-gray-900 text-white p-4 sm:p-6 md:p-8">

    <div id="loadingScreen" class="fixed inset-0 bg-gray-900 z-50 flex items-center justify-center p-4">
        <div class="text-center max-w-2xl">
            <div class="loader inline-block"></div>
            <div id="loadingStatus" class="text-gray-400 mt-4 text-lg">Autenticando...</div>
        </div>
    </div>

    <div id="appContainer" class="hidden max-w-screen-2xl mx-auto">
        <header class="text-center mb-6 relative">
            <h1 class="text-3xl sm:text-4xl font-bold text-transparent bg-clip-text bg-gradient-to-r from-yellow-400 to-orange-500">Day Trade Dólar PRO</h1>
            <p class="text-gray-400 mt-1">Backtesting e Simulação Intraday para USD/BRL</p>
            <div class="absolute top-0 left-0">
                <a href="./index.html" class="bg-gray-700 hover:bg-gray-600 text-white text-xs font-bold py-2 px-3 rounded-lg inline-flex items-center transition">
                    <svg class="w-4 h-4 mr-2" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M10 19l-7-7m0 0l7-7m-7 7h18"></path></svg>
                    Voltar
                </a>
            </div>
        </header>

        <div class="grid grid-cols-1 lg:grid-cols-4 gap-6">
            <div class="lg:col-span-1 space-y-6">
                <div class="bg-gray-800 p-4 rounded-lg shadow-lg">
                    <h3 class="font-semibold text-lg mb-4 text-gray-200">1. Carregar Dados Históricos</h3>
                    <div class="space-y-4">
                        <button id="loadDataBtn" class="w-full bg-blue-600 hover:bg-blue-700 text-white font-bold py-3 px-4 rounded-lg transition">
                            Carregar Histórico (Diário & Intraday)
                        </button>
                        <div id="dataStatus" class="text-center text-xs text-gray-400 pt-2"></div>
                    </div>
                </div>

                <div id="backtestControls" class="bg-gray-800 p-4 rounded-lg shadow-lg hidden">
                    <h3 class="font-semibold text-lg mb-4 text-gray-200">2. Backtest</h3>
                    <div class="space-y-4">
                         <div>
                            <label for="timeframeSelect" class="block mb-1 text-sm font-medium text-gray-300">Timeframe para Análise</label>
                            <select id="timeframeSelect" class="bg-gray-700 border border-gray-600 text-white text-sm rounded-lg focus:ring-blue-500 focus:border-blue-500 block w-full p-2.5">
                                <option value="5min">5 Minutos</option>
                                <option value="15min">15 Minutos</option>
                                <option value="30min">30 Minutos</option>
                                <option value="60min">1 Hora</option>
                                <option value="daily" selected>Diário</option>
                                <option value="weekly">Semanal</option>
                                <option value="monthly">Mensal</option>
                            </select>
                        </div>
                        <div>
                            <label for="smaPeriod" class="block mb-1 text-sm font-medium text-gray-300">Período da Média Móvel</label>
                            <input type="number" id="smaPeriod" value="21" min="2" class="bg-gray-700 border border-gray-600 text-white text-sm rounded-lg focus:ring-blue-500 focus:border-blue-500 block w-full p-2.5">
                        </div>
                        <button id="runBacktestBtn" class="w-full bg-green-600 hover:bg-green-700 text-white font-bold py-2 px-4 rounded-lg transition">Rodar Backtest</button>
                        <button id="optimizeSmaBtn" class="w-full bg-indigo-600 hover:bg-indigo-700 text-white font-bold py-2 px-4 rounded-lg transition">Otimizar Média (5-100)</button>
                    </div>
                </div>
                
                <div id="simulationControls" class="bg-gray-800 p-4 rounded-lg shadow-lg hidden">
                    <h3 class="font-semibold text-lg mb-4 text-gray-200">3. Simulação (Ao Vivo)</h3>
                    <div class="bg-gray-900/50 p-3 rounded-lg text-center mb-4">
                        <p class="text-sm text-gray-400">Preço Atual</p>
                        <p id="currentPriceDisplay" class="text-2xl font-bold text-yellow-400">--.----</p>
                    </div>
                    <div class="space-y-3">
                        <div>
                            <label for="orderQuantity" class="block mb-1 text-sm font-medium text-gray-300">Quantidade (Contratos)</label>
                            <input type="number" id="orderQuantity" value="1" min="1" class="bg-gray-700 border border-gray-600 text-white text-sm rounded-lg w-full p-2.5">
                        </div>
                        <div class="flex gap-3">
                            <button id="buyBtn" class="flex-1 bg-blue-600 hover:bg-blue-700 text-white font-bold py-3 rounded-lg transition">COMPRAR</button>
                            <button id="sellBtn" class="flex-1 bg-red-600 hover:red-700 text-white font-bold py-3 rounded-lg transition">VENDER</button>
                        </div>
                        <div class="flex gap-3 pt-2">
                             <button id="closePositionBtn" class="flex-1 bg-yellow-600 hover:bg-yellow-700 text-white font-bold py-2 rounded-lg transition">ZERAR</button>
                             <button id="reversePositionBtn" class="flex-1 bg-gray-600 hover:bg-gray-500 text-white font-bold py-2 rounded-lg transition">REVERTER</button>
                        </div>
                    </div>
                    <div id="positionInfo" class="mt-4 space-y-2 text-sm border-t border-gray-700 pt-4">
                        <div class="flex justify-between"><span class="text-gray-400">Posição:</span><span id="posStatus" class="font-semibold">Zerado</span></div>
                        <div class="flex justify-between"><span class="text-gray-400">Quantidade:</span><span id="posQuantity" class="font-semibold">0</span></div>
                        <div class="flex justify-between"><span class="text-gray-400">Preço Médio:</span><span id="posAvgPrice" class="font-semibold">0.0000</span></div>
                        <hr class="border-gray-700 my-1">
                        <div class="flex justify-between"><span class="text-gray-400">Resultado Aberto:</span><span id="posOpenPnl" class="font-bold text-lg">R$ 0,00</span></div>
                        <div class="flex justify-between"><span class="text-gray-400">Resultado do Dia:</span><span id="posClosedPnl" class="font-bold text-lg">R$ 0,00</span></div>
                    </div>
                </div>
            </div>

            <div class="lg:col-span-3 space-y-6">
                <div class="bg-gray-800 p-4 rounded-lg shadow-lg">
                    <h3 class="font-semibold text-lg mb-4 text-center text-gray-200">Gráfico - USD/BRL (<span id="chartTimeframeLabel">Diário</span>)</h3>
                    <div class="chart-container"><canvas id="priceChart"></canvas></div>
                    <div id="chartError" class="hidden text-center text-red-400 p-4"></div>
                </div>

                <div id="resultsSection" class="hidden bg-gray-800 p-6 rounded-lg shadow-lg">
                    <h2 class="text-2xl font-bold text-center mb-6 text-transparent bg-clip-text bg-gradient-to-r from-green-400 to-blue-500">Resultados do Backtest</h2>
                    <div id="statsContainer" class="grid grid-cols-2 md:grid-cols-4 gap-4 mb-6"></div>
                    <div id="startReplayContainer" class="text-center hidden">
                        <button id="startReplayBtn" class="bg-purple-600 hover:bg-purple-700 text-white font-bold py-3 px-6 rounded-lg transition">Iniciar Simulação ao Vivo</button>
                    </div>
                </div>

                <div id="optimizationResultsSection" class="hidden bg-gray-800 p-6 rounded-lg shadow-lg">
                    <h2 class="text-2xl font-bold text-center mb-6 text-transparent bg-clip-text bg-gradient-to-r from-indigo-400 to-purple-500">Resultados da Otimização</h2>
                    <div id="bestResultDisplay" class="bg-gray-900/50 border-2 border-green-500 p-4 rounded-lg mb-6 text-center max-w-md mx-auto"></div>
                    <div class="data-table-container rounded-lg border border-gray-700" style="max-height: 300px;">
                        <table id="optimizationResultTable" class="min-w-full text-sm text-left text-gray-300"></table>
                    </div>
                </div>
            </div>
        </div>
    </div>
    
    <script type="module">
        // --- Firebase e Autenticação ---
        import { initializeApp } from "https://www.gstatic.com/firebasejs/9.22.1/firebase-app.js";
        import { getAuth, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/9.22.1/firebase-auth.js";
        const firebaseConfig = {
            apiKey: "AIzaSyCMIdzeoPFrT8WRElUBes7GTrcsoGzLBiI",
            authDomain: "backtest-f5072.firebaseapp.com",
            projectId: "backtest-f5072",
            storageBucket: "backtest-f5072.appspot.com",
            messagingSenderId: "694914388064",
            appId: "1:694914388064:web:e5ac46c00612142d33b305"
        };
        const app = initializeApp(firebaseConfig);
        const auth = getAuth(app);

        // --- Variáveis Globais ---
        let priceChart = null;
        let dayTradeState = {};
        let dailyHistoricalData = [];
        let intradayHistoricalData = [];
        let aggregatedData = [];
        let replayInterval = null;
        const ALPHA_VANTAGE_API_KEY = 'S4P8G3AM85JSR29T';
        // --- CORREÇÃO: Adicionado multiplicador do contrato de mini-dólar ---
        const CONTRACT_MULTIPLIER = 10000;

        const ui = {
            loadingScreen: document.getElementById('loadingScreen'),
            loadingStatus: document.getElementById('loadingStatus'),
            appContainer: document.getElementById('appContainer'),
            timeframeSelect: document.getElementById('timeframeSelect'),
            loadDataBtn: document.getElementById('loadDataBtn'),
            dataStatus: document.getElementById('dataStatus'),
            backtestControls: document.getElementById('backtestControls'),
            smaPeriod: document.getElementById('smaPeriod'),
            runBacktestBtn: document.getElementById('runBacktestBtn'),
            optimizeSmaBtn: document.getElementById('optimizeSmaBtn'),
            simulationControls: document.getElementById('simulationControls'),
            currentPriceDisplay: document.getElementById('currentPriceDisplay'),
            orderQuantity: document.getElementById('orderQuantity'),
            buyBtn: document.getElementById('buyBtn'),
            sellBtn: document.getElementById('sellBtn'),
            closePositionBtn: document.getElementById('closePositionBtn'),
            reversePositionBtn: document.getElementById('reversePositionBtn'),
            positionInfo: document.getElementById('positionInfo'),
            posStatus: document.getElementById('posStatus'),
            posQuantity: document.getElementById('posQuantity'),
            posAvgPrice: document.getElementById('posAvgPrice'),
            posOpenPnl: document.getElementById('posOpenPnl'),
            posClosedPnl: document.getElementById('posClosedPnl'),
            priceChart: document.getElementById('priceChart'),
            chartTimeframeLabel: document.getElementById('chartTimeframeLabel'),
            chartError: document.getElementById('chartError'),
            resultsSection: document.getElementById('resultsSection'),
            statsContainer: document.getElementById('statsContainer'),
            startReplayContainer: document.getElementById('startReplayContainer'),
            startReplayBtn: document.getElementById('startReplayBtn'),
            optimizationResultsSection: document.getElementById('optimizationResultsSection'),
            bestResultDisplay: document.getElementById('bestResultDisplay'),
            optimizationResultTable: document.getElementById('optimizationResultTable'),
        };

        onAuthStateChanged(auth, user => {
            if (user) {
                ui.loadingScreen.classList.add('hidden');
                ui.appContainer.classList.remove('hidden');
                setupInitialChart();
            } else {
                window.location.href = './index.html';
            }
        });

        async function loadAllData() {
            ui.loadDataBtn.disabled = true;
            ui.chartError.classList.add('hidden');
            if (replayInterval) clearInterval(replayInterval);

            try {
                // Fetch Daily Data (for long-term backtesting)
                ui.dataStatus.textContent = 'Carregando dados diários (20+ anos)...';
                const dailyResponse = await fetch(`https://www.alphavantage.co/query?function=FX_DAILY&from_symbol=USD&to_symbol=BRL&outputsize=full&apikey=${ALPHA_VANTAGE_API_KEY}`);
                const dailyJson = await dailyResponse.json();
                if (dailyJson['Error Message'] || !dailyJson['Time Series FX (Daily)']) {
                     throw new Error(dailyJson['Note'] || 'Falha ao buscar dados diários. Limite da API pode ter sido atingido.');
                }
                const dailySeries = dailyJson['Time Series FX (Daily)'];
                dailyHistoricalData = Object.entries(dailySeries).map(([date, values]) => ({
                    date: new Date(date),
                    open: parseFloat(values['1. open']), high: parseFloat(values['2. high']),
                    low: parseFloat(values['3. low']), close: parseFloat(values['4. close'])
                })).sort((a, b) => a.date - b.date);

                // Fetch Recent Intraday Data (for short-term backtesting)
                ui.dataStatus.textContent = 'Carregando dados intraday recentes...';
                const intradayResponse = await fetch(`https://www.alphavantage.co/query?function=FX_INTRADAY&from_symbol=USD&to_symbol=BRL&interval=5min&outputsize=full&apikey=${ALPHA_VANTAGE_API_KEY}`);
                const intradayJson = await intradayResponse.json();
                if (intradayJson['Error Message'] || !intradayJson['Time Series FX (5min)']) {
                    console.warn("Não foi possível carregar dados intraday, a simulação ao vivo ainda funcionará.");
                    intradayHistoricalData = [];
                } else {
                    const intradaySeries = intradayJson['Time Series FX (5min)'];
                    intradayHistoricalData = Object.entries(intradaySeries).map(([date, values]) => ({
                        date: new Date(date.replace(" ", "T") + "Z"), // Adjust for timezone
                        open: parseFloat(values['1. open']), high: parseFloat(values['2. high']),
                        low: parseFloat(values['3. low']), close: parseFloat(values['4. close'])
                    })).sort((a, b) => a.date - b.date);
                }

                ui.dataStatus.textContent = `Dados carregados: ${dailyHistoricalData.length} dias & ${intradayHistoricalData.length} candles de 5min.`;
                ui.backtestControls.classList.remove('hidden');
                ui.startReplayContainer.classList.remove('hidden');
                processAndDisplayData();

            } catch (error) {
                console.error("Erro ao carregar dados:", error);
                ui.chartError.textContent = `Erro: ${error.message}`;
                ui.chartError.classList.remove('hidden');
                ui.dataStatus.textContent = 'Falha ao carregar dados.';
            } finally {
                ui.loadDataBtn.disabled = false;
            }
        }
        
        function aggregateData(baseData, timeframe) {
            if (!baseData || baseData.length === 0) return [];
            if (timeframe === 'daily' || (timeframe === '5min' && baseData === intradayHistoricalData)) return baseData;
            
            const isDailyAggregation = ['weekly', 'monthly'].includes(timeframe);
            const aggregated = [];
            let currentCandle = null;

            for (const candle of baseData) {
                let intervalStart;
                const d = new Date(candle.date);
                if (isDailyAggregation) {
                    if (timeframe === 'weekly') {
                        const day = d.getUTCDay();
                        intervalStart = new Date(d.setUTCDate(d.getUTCDate() - day));
                    } else { // monthly
                        intervalStart = new Date(Date.UTC(d.getUTCFullYear(), d.getUTCMonth(), 1));
                    }
                    intervalStart.setUTCHours(0,0,0,0);
                } else { // Intraday aggregation
                    const timeframeMinutes = parseInt(timeframe.replace('min', ''));
                    const candleTimestamp = d.getTime();
                    intervalStart = new Date(Math.floor(candleTimestamp / (timeframeMinutes * 60000)) * (timeframeMinutes * 60000));
                }

                if (!currentCandle || intervalStart.getTime() !== currentCandle.date.getTime()) {
                    if (currentCandle) aggregated.push(currentCandle);
                    currentCandle = { date: intervalStart, open: candle.open, high: candle.high, low: candle.low, close: candle.close };
                } else {
                    currentCandle.high = Math.max(currentCandle.high, candle.high);
                    currentCandle.low = Math.min(currentCandle.low, candle.low);
                    currentCandle.close = candle.close;
                }
            }
            if (currentCandle) aggregated.push(currentCandle);
            return aggregated;
        }

        function processAndDisplayData() {
            const selectedTimeframe = ui.timeframeSelect.value;
            ui.chartTimeframeLabel.textContent = ui.timeframeSelect.options[ui.timeframeSelect.selectedIndex].text;
            
            if (['daily', 'weekly', 'monthly'].includes(selectedTimeframe)) {
                aggregatedData = aggregateData(dailyHistoricalData, selectedTimeframe);
            } else {
                aggregatedData = aggregateData(intradayHistoricalData, selectedTimeframe);
            }
            
            updatePriceChart(aggregatedData, [], null);
        }

        function setupInitialChart() {
            const ctx = ui.priceChart.getContext('2d');
            if (priceChart) priceChart.destroy();
            priceChart = new Chart(ctx, {
                type: 'candlestick', data: { datasets: [] },
                options: { responsive: true, maintainAspectRatio: false, scales: { x: { type: 'time', time: { unit: 'year' }, ticks: { color: '#d1d5db' } }, y: { ticks: { color: '#d1d5db' } } }, plugins: { legend: { labels: { color: '#d1d5db' }}, zoom: { pan: { enabled: true, mode: 'x'}, zoom: { wheel: { enabled: true }, mode: 'x'}}}}
            });
        }

        function updatePriceChart(data, trades, smaData) {
            if (!priceChart) setupInitialChart();
            const datasets = [{
                label: 'Preço USD/BRL',
                data: data.map(d => ({ x: d.date.getTime(), o: d.open, h: d.high, l: d.low, c: d.close }))
            }];
            if (smaData) datasets.push({ label: `SMA(${ui.smaPeriod.value})`, type: 'line', data: smaData.filter(d => d.sma).map(d => ({ x: d.date.getTime(), y: d.sma })), borderColor: 'rgb(250, 204, 21)', borderWidth: 1.5, pointRadius: 0 });
            if (trades && trades.length > 0) {
                datasets.push({ label: 'Compra', type: 'scatter', data: trades.filter(t => t.type === 'BUY').map(t => ({x: t.date.getTime(), y: t.price})), backgroundColor: 'rgba(34, 197, 94, 1)', pointStyle: 'triangle', rotation: 0, radius: 7 });
                datasets.push({ label: 'Venda', type: 'scatter', data: trades.filter(t => t.type === 'SELL').map(t => ({x: t.date.getTime(), y: t.price})), backgroundColor: 'rgba(239, 68, 68, 1)', pointStyle: 'triangle', rotation: 180, radius: 7 });
            }
            priceChart.data.datasets = datasets;
            const timeUnit = data.length > 365 * 2 ? 'year' : (data.length > 60 ? 'month' : 'day');
            priceChart.options.scales.x.time.unit = timeUnit;
            priceChart.update();
        }

        function runBacktest(data, smaPeriod) {
            const dataWithSma = calculateSMA(data, smaPeriod);
            const result = generateSignals(dataWithSma);
            const stats = calculateStats(result.trades);
            return { stats, trades: result.trades, dataWithSma };
        }

        function handleRunBacktest() {
            const smaPeriod = parseInt(ui.smaPeriod.value);
            if (aggregatedData.length < smaPeriod) { alert(`Dados insuficientes para a média de ${smaPeriod} períodos.`); return; }
            const { stats, trades, dataWithSma } = runBacktest(aggregatedData, smaPeriod);
            displayBacktestResults(stats);
            updatePriceChart(aggregatedData, trades, dataWithSma);
            ui.resultsSection.classList.remove('hidden');
            ui.optimizationResultsSection.classList.add('hidden');
            ui.resultsSection.scrollIntoView({ behavior: 'smooth' });
        }

        function handleOptimization() {
            ui.optimizeSmaBtn.disabled = true; ui.optimizeSmaBtn.textContent = "Otimizando...";
            setTimeout(() => {
                const results = [];
                for (let period = 5; period <= 100; period += 5) {
                    if (aggregatedData.length < period) continue;
                    const { stats } = runBacktest(aggregatedData, period);
                    results.push({ period, ...stats });
                }
                displayOptimizationResults(results);
                ui.optimizeSmaBtn.disabled = false; ui.optimizeSmaBtn.textContent = "Otimizar Média (5-100)";
                ui.optimizationResultsSection.scrollIntoView({ behavior: 'smooth' });
            }, 50);
        }

        function displayBacktestResults(stats) {
            const fmtr = (v) => formatCurrency(v, 'BRL');
            ui.statsContainer.innerHTML = `<div class="bg-gray-700/50 p-3 rounded-lg text-center"><p class="text-sm text-gray-400">Resultado Total</p><p class="text-xl font-bold ${stats.totalProfit >= 0 ? 'text-green-400' : 'text-red-400'}">${fmtr(stats.totalProfit)}</p></div><div class="bg-gray-700/50 p-3 rounded-lg text-center"><p class="text-sm text-gray-400">Taxa de Acerto</p><p class="text-xl font-bold text-blue-400">${stats.winRate.toFixed(2)}%</p></div><div class="bg-gray-700/50 p-3 rounded-lg text-center"><p class="text-sm text-gray-400">Drawdown Máximo</p><p class="text-xl font-bold text-red-400">${fmtr(stats.maxDrawdown)}</p></div><div class="bg-gray-700/50 p-3 rounded-lg text-center"><p class="text-sm text-gray-400">Total de Trades</p><p class="text-xl font-bold text-yellow-400">${stats.totalTrades}</p></div>`;
        }

        function displayOptimizationResults(results) {
             const fmtr = (v) => formatCurrency(v, 'BRL');
             if (results.length === 0) return;
             const bestResult = results.reduce((max, current) => current.totalProfit > max.totalProfit ? current : max, results[0]);
             ui.bestResultDisplay.innerHTML = `<p class="text-sm text-gray-400">Melhor Resultado</p><h4 class="text-2xl font-bold text-green-400">Média de ${bestResult.period}</h4><p class="text-md text-gray-300">Lucro: <strong>${fmtr(bestResult.totalProfit)}</strong></p>`;
             let tableHTML = `<thead class="text-xs text-gray-200 uppercase bg-gray-700 sticky top-0"><tr><th class="px-4 py-2 text-center">Período</th><th class="px-4 py-2 text-right">Resultado</th><th class="px-4 py-2 text-right">Acerto</th><th class="px-4 py-2 text-right">Trades</th></tr></thead><tbody>`;
             results.forEach(res => {
                const isBest = res.period === bestResult.period;
                tableHTML += `<tr class="hover:bg-gray-700/50 ${isBest ? 'bg-green-800/30 font-bold' : ''}"><td class="px-4 py-1 border-b border-gray-700 text-center">${res.period}</td><td class="px-4 py-1 border-b border-gray-700 text-right ${res.totalProfit >= 0 ? 'text-green-400' : 'text-red-400'}">${fmtr(res.totalProfit)}</td><td class="px-4 py-1 border-b border-gray-700 text-right">${res.winRate.toFixed(1)}%</td><td class="px-4 py-1 border-b border-gray-700 text-right">${res.totalTrades}</td></tr>`;
             });
             ui.optimizationResultTable.innerHTML = tableHTML + '</tbody>';
             ui.resultsSection.classList.add('hidden');
             ui.optimizationResultsSection.classList.remove('hidden');
        }

        async function fetchLivePriceForReplay() {
            try {
                const response = await fetch('https://economia.awesomeapi.com.br/last/USD-BRL');
                if (!response.ok) return;
                const data = await response.json();
                const newPrice = parseFloat(data.USDBRL.bid);
                dayTradeState.currentPrice = newPrice;
                ui.currentPriceDisplay.textContent = newPrice.toFixed(4);
                const chart = priceChart;
                if (chart && chart.data.datasets[0]) {
                    const chartData = chart.data.datasets[0].data;
                    chartData.push({ x: Date.now(), y: newPrice });
                    if (chartData.length > 200) chartData.shift();
                    chart.update('none');
                }
                if (dayTradeState.position !== 'FLAT') { calculateOpenPnl(); updatePositionUI(); }
            } catch (error) { console.warn("Falha ao buscar preço ao vivo:", error); }
        }

        function handleStartReplay() {
            if (replayInterval) clearInterval(replayInterval);
            ui.simulationControls.classList.remove('hidden');
            ui.chartTimeframeLabel.textContent = "Ao Vivo";
            resetSimulationState();
            priceChart.destroy();
            const ctx = ui.priceChart.getContext('2d');
            priceChart = new Chart(ctx, {
                type: 'line',
                data: { datasets: [{ label: 'Cotação USD/BRL', data: [], borderColor: '#facc15', borderWidth: 2, pointRadius: 0, tension: 0.1 }] },
                options: { responsive: true, maintainAspectRatio: false, scales: { x: { type: 'time', time: { unit: 'minute', displayFormats: { minute: 'HH:mm:ss' } }, ticks: { color: '#d1d5db' } }, y: { ticks: { color: '#d1d5db' } } }, plugins: { legend: { display: false }}}
            });
            fetchLivePriceForReplay();
            replayInterval = setInterval(fetchLivePriceForReplay, 10000);
        }
        
        function calculateSMA(data, period) { return data.map((row, i, arr) => (i < period - 1) ? { ...row, sma: null } : { ...row, sma: arr.slice(i - period + 1, i + 1).reduce((acc, curr) => acc + curr.close, 0) / period }); }
        
        function generateSignals(data) {
            const trades = []; let position = 'FLAT';
            for (let i = 1; i < data.length; i++) {
                const prev = data[i-1], curr = data[i];
                if (!prev.sma || !curr.sma) continue;
                if (prev.close < prev.sma && curr.close > curr.sma) { if (position !== 'LONG') { trades.push({ type: 'BUY', date: curr.date, price: curr.close }); position = 'LONG'; }}
                else if (prev.close > prev.sma && curr.close < curr.sma) { if (position !== 'SHORT') { trades.push({ type: 'SELL', date: curr.date, price: curr.close }); position = 'SHORT'; }}
            }
            return { trades };
        }
        
        function calculateStats(trades) {
            if (trades.length < 2) return { totalProfit: 0, winRate: 0, maxDrawdown: 0, totalTrades: trades.length };
            let totalProfit = 0, wins = 0, closedTradesCount = 0;
            const equityCurve = [0];
            for (let i = 0; i < trades.length - 1; i++) {
                const entry = trades[i], exit = trades[i+1];
                // --- CORREÇÃO: Aplicado o multiplicador do contrato ---
                const profit = ((entry.type === 'BUY') ? (exit.price - entry.price) : (entry.price - exit.price)) * CONTRACT_MULTIPLIER;
                if (profit > 0) wins++;
                totalProfit += profit;
                closedTradesCount++;
                equityCurve.push(totalProfit);
            }
            let peak = 0, maxDrawdown = 0;
            equityCurve.forEach(equity => { if (equity > peak) peak = equity; if (peak - equity > maxDrawdown) maxDrawdown = peak - equity; });
            return { totalProfit, winRate: (wins / closedTradesCount) * 100 || 0, maxDrawdown, totalTrades: trades.length };
        }
        
        function formatCurrency(v, c = 'BRL') { return new Intl.NumberFormat('pt-BR', { style: 'currency', currency: c }).format(v); }

        function resetSimulationState() {
            dayTradeState = { position: 'FLAT', quantity: 0, avgPrice: 0, openPnl: 0, closedPnl: 0, currentPrice: 0 };
            updatePositionUI();
        }

        function executeTrade(type, forcedQuantity = null) {
            const quantity = forcedQuantity || parseInt(ui.orderQuantity.value);
            const price = dayTradeState.currentPrice;
            if (quantity <= 0 || price <= 0) return;
            const { position: currentPosition, quantity: currentQty } = dayTradeState;
            if (type === 'BUY') {
                if (currentPosition === 'FLAT') { dayTradeState.position = 'LONG'; dayTradeState.avgPrice = price; dayTradeState.quantity = quantity; }
                else if (currentPosition === 'LONG') { dayTradeState.avgPrice = ((dayTradeState.avgPrice * currentQty) + (price * quantity)) / (currentQty + quantity); dayTradeState.quantity += quantity; }
                else { const q = Math.min(quantity, currentQty), r = quantity - q; closePosition(price, q); if (r > 0) { dayTradeState.position = 'LONG'; dayTradeState.avgPrice = price; dayTradeState.quantity = r; } }
            } else if (type === 'SELL') {
                if (currentPosition === 'FLAT') { dayTradeState.position = 'SHORT'; dayTradeState.avgPrice = price; dayTradeState.quantity = quantity; }
                else if (currentPosition === 'SHORT') { dayTradeState.avgPrice = ((dayTradeState.avgPrice * currentQty) + (price * quantity)) / (currentQty + quantity); dayTradeState.quantity += quantity; }
                else { const q = Math.min(quantity, currentQty), r = quantity - q; closePosition(price, q); if (r > 0) { dayTradeState.position = 'SHORT'; dayTradeState.avgPrice = price; dayTradeState.quantity = r; } }
            }
            updatePositionUI();
        }

        function closePosition(price, qtyToClose = dayTradeState.quantity) {
            if (dayTradeState.position === 'FLAT' || qtyToClose <= 0) return;
            // --- CORREÇÃO: Aplicado o multiplicador do contrato ---
            const pnl = ((dayTradeState.position === 'LONG') ? (price - dayTradeState.avgPrice) : (dayTradeState.avgPrice - price)) * qtyToClose * CONTRACT_MULTIPLIER;
            dayTradeState.closedPnl += pnl;
            dayTradeState.quantity -= qtyToClose;
            if (dayTradeState.quantity <= 0) { dayTradeState.position = 'FLAT'; dayTradeState.quantity = 0; dayTradeState.avgPrice = 0; dayTradeState.openPnl = 0; }
            updatePositionUI();
        }
        
        function calculateOpenPnl() {
            if (dayTradeState.position === 'FLAT') { dayTradeState.openPnl = 0; return; }
            // --- CORREÇÃO: Aplicado o multiplicador do contrato ---
            const pnl = ((dayTradeState.position === 'LONG') ? (dayTradeState.currentPrice - dayTradeState.avgPrice) : (dayTradeState.avgPrice - dayTradeState.currentPrice)) * dayTradeState.quantity * CONTRACT_MULTIPLIER;
            dayTradeState.openPnl = pnl;
        }

        function updatePositionUI() {
            const { position, quantity, avgPrice, openPnl, closedPnl } = dayTradeState;
            ui.posStatus.textContent = position === 'LONG' ? 'Comprado' : position === 'SHORT' ? 'Vendido' : 'Zerado';
            ui.posQuantity.textContent = quantity;
            ui.posAvgPrice.textContent = avgPrice.toFixed(4);
            ui.posOpenPnl.textContent = formatCurrency(openPnl);
            ui.posOpenPnl.className = `font-bold text-lg day-trade-info-value ${openPnl >= 0 ? 'positive' : 'negative'}`;
            ui.posClosedPnl.textContent = formatCurrency(closedPnl);
            ui.posClosedPnl.className = `font-bold text-lg day-trade-info-value ${closedPnl >= 0 ? 'positive' : 'negative'}`;
        }
        
        ui.loadDataBtn.addEventListener('click', loadAllData);
        ui.timeframeSelect.addEventListener('change', () => { if (dailyHistoricalData.length > 0 || intradayHistoricalData.length > 0) processAndDisplayData(); });
        ui.runBacktestBtn.addEventListener('click', handleRunBacktest);
        ui.optimizeSmaBtn.addEventListener('click', handleOptimization);
        ui.startReplayBtn.addEventListener('click', handleStartReplay);
        ui.buyBtn.addEventListener('click', () => executeTrade('BUY'));
        ui.sellBtn.addEventListener('click', () => executeTrade('SELL'));
        ui.closePositionBtn.addEventListener('click', () => closePosition(dayTradeState.currentPrice));
        ui.reversePositionBtn.addEventListener('click', () => { if (dayTradeState.position !== 'FLAT') executeTrade(dayTradeState.position === 'LONG' ? 'SELL' : 'BUY', dayTradeState.quantity * 2); });

    </script>
</body>
</html>